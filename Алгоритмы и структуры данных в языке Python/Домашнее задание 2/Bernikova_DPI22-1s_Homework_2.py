# Фёдору надо получить справку в поликлинике.
# На ввод подается файл input.txt, в котором в первой строке записано число N - номер справки, которую надо получить Фёдору (число - целое, больше нуля),
# Далее i-я строка хранит описание номеров справок, выдаваемых и требуемых определенным врачом в формате:
# <ФИО ВРАЧА>;<номер выдаваемой справки>,<номер требуемой для ее выдачи справки>;... <номер выдаваемой справки>,<номер требуемой для ее выдачи справки>;
# В этой строке <ФИО ВРАЧА> - уникальное непустое поле. <номер выдаваемой справки> - целое число, большее нуля. <номер требуемой для ее выдачи справки> - 
# либо целое больше нуля число, либо пустая строка (то есть, в этом случае после запятой сразу стоит точка с запятой).
# Сначала Фёдор может пойти только к врачу, который может выдать ему справку, для которой <требуемая для ее выдачи справка> - пустое поле. 
# В дальнейшем Фёдор может получить справку у врача, предъявив ему одну из справок, полученных ранее.
# Напишите программу для Фёдора, которая сообщит ему, можно ли получить требующуюся ему справку в данной поликлинике и, если справку можно получить, - 
# последовательность обхода врачей и предъявляемых и получаемых при этом справок.
# Результатом работы программы должен быть файл output.txt, в котором в первой строке содержится true или false, что обозначает, можно ли получить справку. 
# Если false, то дальше никаких строк в файле нет. Иначе дальше находятся строки вида:
# <ФИО ВРАЧА>;<номер предъявляемой Фёдором справки>,<номер получаемой Фёдором справки>
# Таким образом, - последняя из строк этого вида строка файла должна будет содержать номер справки, требующейся Фёдору.
# Замечание1. Поле <номер предъявляемой Фёдором справки> может быть пустым.
# Замечание2. Ноутбук, на котором Фёдор будет запускать программу, - очень старый, памяти мало, работает медленно. Поэтому рекурсию в программе использовать нельзя.

# Тестовые данные ввод:
# 2
# A;1,2;3,;
# B;6,3;5,;4,2;
# C;2,1;

# Вывод: false

# Тестовые данные ввод:
# 6
# A;1,2;3,;
# B;6,3;5,;4,2;
# C;2,1;

# Вывод:
# true
# A;None,3
# B;3,6
# 6

from collections import deque  # импорт класса deque из модуля collections

# чтение данных из файла input.txt
with open('input.txt', 'r') as f:  
    N = int(f.readline().strip())  
    doctors = {} 
    for line in f: 
        data = line.strip().split(';')  
        doctor = data[0]  
        papers = {}  
        for i in range(1, len(data)):  
            if data[i]:  
                p1, p2 = data[i].split(',')  
                papers[int(p1)] = int(p2) if p2 else None  
        doctors[doctor] = papers  

# поиск нужной справки с помощью BFS
queue = deque()  # создание очереди из модуля collections
visited = set()  # создание множества для хранения посещенных состояний
queue.append((None, None, []))  # добавление начального состояния в очередь
while queue:  # пока очередь не пуста
    current_doctor, current_paper, obtained_papers = queue.popleft()  # извлечение первого элемента из очереди
    result = [] # для определения имяни "result" 
    if current_paper == N:  # если найдена нужная справка
        result = obtained_papers + [(None, None, N)]  # сохранение последовательности полученных справок
        break  # выход из цикла
    for doctor, papers in doctors.items():  # цикл по всем врачам и их справкам
        if doctor != current_doctor and current_paper in papers and (not papers[current_paper] or papers[current_paper] == current_paper):
            # если врач не является текущим врачом, у него есть нужная справка и она соответствует текущей справке
            new_obtained_papers = obtained_papers + [(current_doctor, current_paper, papers[current_paper])]  # создание новой последовательности полученных справок
            if (doctor, papers[current_paper]) not in visited:  # если состояние еще не посещалось
                queue.append((doctor, papers[current_paper], new_obtained_papers))  # добавление нового состояния в очередь
                visited.add((doctor, papers[current_paper]))  # добавление состояния в множество посещенных состояний
    for paper in range(1, N+1):  # цикл по всем справкам
        if paper not in obtained_papers:  # если справка еще не получена
            for doctor, papers in doctors.items():  # цикл по всем врачам и их справкам
                if doctor != current_doctor and paper in papers and (not papers[paper] or papers[paper] == current_paper):
                    # если врач не является текущим врачом, у него есть нужная справка и она соответствует предыдущей справке
                    new_obtained_papers = obtained_papers + [(current_doctor, current_paper, paper)]  # создание новой последовательности полученных справок
                    if (doctor, paper) not in visited:  # если состояние еще не посещалось
                        queue.append((doctor, paper, new_obtained_papers))  # добавление нового состояния в очередь
                        visited.add((doctor, paper))  # добавление состояния в множество посещенных состояний

# запись результата в файл output.txt
with open('output.txt', 'w+') as f: 
    if result:  
        f.write('true\n')  
        for r in result[:-1]: 
            for doctor, papers_dict in doctors.items(): 
                if r[2] in papers_dict and (not papers_dict[r[2]] or papers_dict[r[2]] == r[1]):  
                    f.write(f'{doctor};{r[1]},{r[2]}\n') 
                    break
        f.write(str(N)) 
    else:
        f.write('false')  